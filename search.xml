<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack4基本入门]]></title>
    <url>%2F2019%2F07%2F16%2Fwebpack4%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[webpack4 基础入门 本文只是我在学习过程中做的笔记而不是精心整理的博客文章…文笔比较差,供大家参考 官网指南:建议跟学教程:常用 在网页中引用的常见静态资源 js css Images fonts 模板文件 .ejs .jade .vue(在webpack中定义组件的方式,推荐这么用,把组件抽离出来)引入的静态资源多了之后的问题 网页加载速度慢,要发起很多的二次请求 要处理错综复杂的依赖关系 如何解决 合并压缩,精灵图,图片的Base64编码(小图片) 可以使用requireJS,也可以使用webpack 什么是webpack?webpack是前端的一个项目构建工具,基于node.js 如何完美实现上述的2种解决方案 使用Gulp,是基于task任务的,小巧灵活,适合小项目 使用webpack,是基于整个项目进行构建的 关于npm常用命令 npm init 生成package.json文件 npm install packgename -g -g 全局安装 -D 开发环境安装,同时注册到开发环境依赖(devDependencies) –save-dev -P 开发环境安装,同时会注册到生产环境依赖(“dependencies”)中去 –save-prod 妈的我晕 -P最好使用 npm install xxxx –save 代替 cnpm npm 最好项目中就选择一个一直用，否则很容易损坏node_modules,晕 关于开发环境依赖和生产环境依赖 webpack初步阶段 安装 npm init -y 生成package.json文件,-y是一路yes的意思 npm i -g webpack 全局安装 npm i -D webpack 在开发环境中安装(推荐这个嗷!) webpack4.0版本以后需要去再安装一个webpack-cli npm i -D webpack-cli 项目目录 123456|-package.json |- /dist 打包后输出 |- ...这里之后都是自动打包之后的文件 |-/src |- index.js 入口文件 |- index.html 安装lodash (使用示例,是一个js的工具库) npm i lodash -P 编写:src/index文件 123456789101112// es6导入包的方法 ,_类似于jq中的$// 其实_这可以随便取值,下面用这个你命名的值当作_用就行了,因为是默认输出import _ from 'lodash';function createDomElement() &#123; var dom = document.createElement('div'); dom.innerHTML = _.join(['aicoder', '.com', ' wow'], ''); return dom;&#125;document.body.appendChild(createDomElement()); 在工程文件下创建webpack.config.js 123456|-package.json |- /dist 打包后输出 |- index.html |-/src |- index.js 入口文件|-webpack.config.js 配置文件,你的文件通过webpack构建的配置都在这里 123456789101112131415161718//webpack.config.js//是node的相关内容,请求了path模块const path = require('path')module.exports = &#123; // 入口文件 entry:'./src/index.js', // 这mode我现在也不知 mode:'development', // 构建后的出口文件配置 output:&#123; filename:'main.js', // 解析为绝对路径, path.resolve('/foo/bar', './baz');:// 返回: '/foo/bar/baz' path:path.resolve(__dirname,'dist') // __dirname,当前文件所在文件夹路径 &#125;&#125; 坑:如果要操作dom此时记得要加html加载完(window.onload)的前置条件 ↑ 是我刚开始学的时候犯的初级错误,大家可以忽略一下 命令行输入 npx webpack 或者 webpack 就会开始构建 在index.html引用刚刚的构建输出文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./main.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;p id="yun"&gt;哥真晕了&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; webpack-dev-server的基本使用webpack-dev-server:自动监听文件的改变,自动打包,自动刷新浏览器 npm i -D webpack-dev-server 工具安装到本地开发依赖 安装完毕后,由于我们是在项目中安装的,所以我们无法将其当作命令直接在powershell中运行, 在package.json 中的script 中加入 123456789"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", //插入 "dev":"webpack-dev-server" //"dev":"webpack-dev-server --open" 可以自动打开浏览器 //"dev":"webpack-dev-server --open --port 3000" 自动打开浏览器,端口为3000 默认为8080 //"dev":"webpack-dev-server --open --port 3000 --contentBase src" 自动打开浏览器,端口为3000 默认为8080,进去的时候自动是src文件夹,里面有index.html的话就直接显示了 //"dev":"webpack-dev-server --open --port 3000 --hot" hot 修改处打补丁,而不是每次重新打包编译,并且异步刷新,不用网页刷新,内容直接更新 &#125;, 执行 `npm run dev` 就可以了 webpack-dev-server 帮我们打包生成的bundel.js文件,并没有存放在实际的物理磁盘上,而是直接托管到了电脑的内存中,所以,我们在项目根目录中,根本找不到这个打包好的文件.我们想要动态更新, 12&lt;script src="/bundle.js"&gt;&lt;/script&gt;&lt;!-- 还要把引入的文件改成项目根目录 --!&gt; 我们可以认为,webpack-dev-server 把打包好的文件用一种虚拟的形式托管到了项目的根目录中,虽然我们都看不到它,但是可以认为,和dist src node_modules 平级有一个看不见的文件:bundle.js (放在内存中是为了刷新速度快) 配置命令的另一种方法不是在package.json中配置而是在webpack.config.js中配置 123456789101112131415161718192021const webpack = require('Webpack')// 第二步!!!!!!module.exports = &#123; entry:path.join(__dirname,'./src/main.js'), mode:'development', output:&#123; filename:'bundle.js', path:path.resolve(__dirname,'dist') &#125;, //---------------------------------------- devServer:&#123; //这是配置命令参数的第二种形式,相对来说麻烦一些 open:true,//自动打开浏览器 port:3000, contentBase:'src',//指定托管的根目录 hot:true//启用热更新 的第一步!!!!!!! &#125;, plugins:[//配置插件的结点 new webpack.HotModuleReplacementPlugin()//new一个热更新的模块对象,第三步!!!!!!!!!!!!!!! ] //---------------------------------------------------&#125; html-webpack-plugin的两个基本作用 是个插件:生成内存中的html页面,在上述中html一直是在硬盘中的,和server一起用，大家都说好~ 在使用这个插件之后,我们可以不用自己去处理添加bundle.js,这个插件会帮我们自动插入 打包好的文件 ,并插入到html文件的末尾 npm i -D html-webpack-plugin 123456789101112131415161718192021//只要是插件,就一定要放到plugins里面const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry:path.join(__dirname,'./src/main.js'), mode:'development', output:&#123; filename:'bundle.js', path:path.resolve(__dirname,'dist') &#125;, //-------------------------------------- plugins:[//配置插件的结点 new htmlWebpackPlugin(&#123; //配置文件//指定 模拟页面,会根据指定的磁盘路径,生成内存中的页面 template:path.join(__dirname,'./src/index.html'), //指定生成的页面的名称 filename:'index.html' &#125;) ] //------------------------------------------&#125; webpack 处理css 模块webpack默认可以解析js ,要处理其他类型的文件,需要安装相应的loader 安装css模块解析的依赖npm install –save-dev style-loader css-loader 在入口文件中import css文件 12// index.jsimport './style/index.css'; //让生成的main.js去帮我们加载这一个模块,同样我们要保证有对应的解析模块 1234567891011121314151617181920212223module.exports = &#123; entry:'./src/index.js', mode:'development', output:&#123; filename:'main.js', // 解析为绝对路径, path.resolve('/foo/bar', './baz');:// 返回: '/foo/bar/baz' path:path.resolve(__dirname,'dist') // __dirname,当前文件所在文件夹路径 &#125;, // --------------------------- module: &#123; // 用于配置所有第三方加载器的规则 rules: [ &#123; // 正则表达式去寻找.css为后缀的,匹配到就用下列加载器处理 test: /\.css$/, // 采用的解析模块,顺序是!!从后到前!! use: ['style-loader', 'css-loader'] &#125; ] &#125; // ------------------------&#125; 在webpack.config.js中添加解析模块规则 加载sass使用sourcemap追踪样式定义源 sass-loader node-sass 123456789101112131415161718192021222324module&#123; rules[&#123; // 这里的test可以是/\.(sc|sa|c)ss$/ 普通css文件也可以经过sass处理 test:/\.scss$/, // 顺序不可以乱,从后往前的 use:[&#123; // 这个只起到注入作业 loader:"style.loader" &#125;,&#123; loader:"css.loader" options:&#123; // 可以让你在网页f12调试样式追踪到源文件中定义的位置 sourceMap:true &#125; &#125;, &#123; loader:"sass.loader" options:&#123; sourceMap:true &#125; &#125; ] &#125;]&#125; import npx webpack 使用PostCSS处理loader(附带:添加css前缀)postcss 反正就是优化你的cssauoprefixer 添加优化前缀,是postcss中的一个功能,postcss中还有很多这种 npm i -D postcss-loader npm i -D autopreficer 12345678910111213141516171819202122232425262728293031323334// webpack.config.js module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; sourceMap: true &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; // 微标识符,用啥都行 ident: 'postcss', sourceMap: true, plugins: loader =&gt; [ require('autoprefixer')(&#123; browsers: ['&gt; 0.15% in CN'] &#125;) // 添加前缀 ] &#125; &#125;, &#123; loader: 'sass-loader', options: &#123; sourceMap: true &#125; &#125; ] &#125; ] &#125; url-loader处理图片和字体默认情况下 webpack无法处理url npm i -D url-loader file-loader 1234567891011121314151617181920module：&#123; rules[ &#123; test:/\.(jpg|png|gif|bmp|jpeg)$/, // file-loader是url-loader的内部以来,与项目没关系,所以不用添加 // ?是传参的方式,所有的loader都可以这样传参 use:'url-loader?limit=7632&amp;name=[hash]-[name].[ext]' // url-loader默认将图片设置为base64,设置limit后,大于等于的就不会被转换 // 如果是不被改造成base64的话,会将其上一个hash值构造的路径,这是为了防止文件重名,webpack打包处理之后会把资源放在同一级下,[name] 原来的名字,[ext],原来的后缀名,[hash:8],生成8位的hash值,hash最高32位 // -------另一种方式:更推荐 use: [ &#123; loader: 'url-loader', // 根据图片大小，把图片优化成base64 options: &#123; limit: 10000 &#125; &#125;, &#125; ]&#125; 关于import1234import $ from 'jquery'import './css/index.css'// 写了 ./ 的是会在文件同级目录下寻找, 不写的话默认去node_modules下寻找import 'bootstrap/dist/css/bootstrap.css' webpack中babel的设置babel:将高级语法转化为浏览器能识别的低级语法,webpack只能处理一部分es6语法 安装两套包 npm i -D babel-core babel-loader babel-plugin-transform-runtime负责转换 npm i -D babel-preset-env babel-preset-stage-0 负责语法 设置webpack.config.js 1234567module:&#123; rules:[ &#123;test:/\.js$/,use:'babel-loader',exclude:/node_modules/ // 主要以exclude,要排除node_modules ,因为不排除的话,babel会把所有第三方js文件都打包编译,会非常消耗性能,同时还有可能会导致包的损坏 &#125; ]&#125; 在项目的分目录中,新建一个叫做.babelrc的配置文件,里面的内容属于json格式 1234&#123; "presets":["env","stage-0"], "plugins":["transform-runtime"]&#125; 总结目前就能够了解webpack的基本架构啦,也不可能一一都写下来,想要更多得了解对其他插件或者文件的处理的话建议去刚开始给出的老马教程里面去学一下,文章可能后续有补充,但是最近因为学习生活很慢近期应该就不会啦~]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[hello world]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>表格</tag>
        <tag>表单验证</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
