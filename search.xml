<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Nginx和pm2通过ip+端口访问你的服务器]]></title>
    <url>%2F2019%2F08%2F20%2F%E4%BD%BF%E7%94%A8Nginx%E5%92%8Cpm2%E9%80%9A%E8%BF%87ip-%E7%AB%AF%E5%8F%A3%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1.前言昨天看到网易云音乐node.js版API，但是因为对node.js的认识只在一些语句上面,苦于不知咋用.结果发现原来就直接node app.js就能在本地服务器localhost中运行.于是就想把他挂到我的vps上面.弄了一下午弄好了.把这次的踩坑经验发上来 我的vps是centos 6版本的 具体步骤: 1. node.js npm 环境配置 2. git配置(我的vps在做gitpage的时候已经配置了,所以就不写了) 3. pm2 4. Nginx2. 配置过程1. node.js配置参考 由于linux上安装文件是真的有很多方式,没具体学过linux的我真的晕晕了,由于我对node的版本没有要求,就直接安装了具体版本号. 推荐以下操作在 /opt 目录下进行 下载压缩包1wget http://developer.jpanj.com/node-v10.15.3-linux-x64.tar.xz 解压为 tar 包1xz -d node-v10.15.3-linux-x64.tar.xz 如果xz命令不存在的话,可以查看博客或者根据一下步骤一步步敲 1wget http://tukaani.org/xz/xz-5.2.2.tar.gz` 1`tar -zxf xz-5.2.2.tar.gz` 12./configure make &amp;&amp; make install 解压1tar -xvf node-v10.15.3-linux-x64.tar 当前目录下软链一个 node 目录出来 这样做的好处是，未来升级版本非常方便，只需要更新这个软链就行 1ln -s ./node-v10.15.3-linux-x64 ./node 通过软链接，将可执行程序放入系统环境变量的路径中 查看当前系统中都有哪些环境变量路径 12# echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin 可以看到我的列表中有： /usr/local/bin /usr/bin 大家约定成俗逻辑是： /usr/bin下面的都是系统预装的可执行程序，会随着系统升级而改变。 /usr/local/bin 目录是给用户放置自己的可执行程序的地方 所以我推荐将软链放在 /usr/local/bin 目录下： 12ln -s /opt/node/bin/node /usr/local/bin/nodeln -s /opt/node/bin/npm /usr/local/bin/npm 但是在这一步我遇到了-bash: cd: src: Too many levels of symbolic links的问题,后续解决方案是我cd ~之后 ln -s /opt/node/bin/node /usr/local/bin/node 来完成的。 如果遇到file exists的问题,就到你软链到的那个地址的命令文件删掉 检查是否安装成功1234[root@dc8 ~]# node -vv10.15.3[root@dc8 ~]# npm -v6.4.1 2. pm2安装pm2npm i -g pm2 通过软链接，将可执行程序放入系统环境变量的路径中因为不像windows,npm下载之后不能够直接在全局环境之中使用 所以也要像之前一样 1ln -s /opt/node/bin/pm2 /usr/local/bin/pm2 3. Nginx参考1 参考2 1.第一步，在/etc/yum.repos.d/目录下创建一个源配置文件nginx.repo：1cd /etc/yum.repos.d/ 1vim nginx.repo 填写如下内容: 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=0enabled=1 保存，则会产生一个/etc/yum.repos.d/nginx.repo文件。 下面直接执行如下指令即可自动安装好Nginx： 1yum install nginx -y 安装完成，下面直接就可以启动Nginx了： 1/etc/init.d/nginx start 现在Nginx已经启动了，直接访问服务器就能看到Nginx欢迎页面了的。 如果还无法访问，则需配置一下Linux防火墙。 1iptables -I INPUT 5 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT 这里注意 之后Nginx要监听哪个端口就必须开放哪个端口,我在这里踩了一下坑 现在我们释放的是默认的80端口 1service iptables save 1service iptables restart Nginx的命令以及配置文件位置： 12345678910/etc/init.d/nginx start # 启动Nginx服务 /etc/init.d/nginx stop # 停止Nginx服务/etc/nginx/nginx.reload # 重启Nginx服务 /etc/nginx/nginx.conf # Nginx配置文件位置chkconfig nginx on #设为开机启动 至此，Nginx已经全部配置安装完成。 2.一台主机上适应多个服务器在你的nginx通过代理的方式转发请求：配置如下vi /etc/nginx/nginx.conf在http加入下面的内容，参考：http://wiki.nginx.org/FullExample 1234567891011121314151617181920212223http &#123;.... server &#123; listen 80; server_name www.a.com; charset utf-8; access_log /home/a.com.access.log main; location / &#123; proxy_pass http://127.0.0.1:80; &#125; &#125; server &#123; listen 80; server_name www.b.com; charset utf-8; access_log /home/b.com.access.log main; location / &#123; proxy_pass http://127.0.0.1:81; &#125; &#125;... 1234567891011121314151617181920212223242526272829303132# 我使用的是这里的资料server &#123; listen 80; server_name www.xxxx.cn; #要访问的域名，我这里用的测试域名，如果有多个，用逗号分开,如果想直接用ip访问,则删除这一行 charset utf8; location / &#123; proxy_pass http://127.0.0.1:8080; #映射到代理服务器，可以是ip加端口, 或url proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125;# 我的node项目是在3000端口运行的,之后 在外网浏览器中访问`你的ip地址:3000即可`server &#123; listen 3000; charset utf8; location / &#123; proxy_pass http://127.0.0.1:3000; #映射到代理服务器，可以是ip加端口, 或url ,4000端口的话就在外网访问4000端口 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 到这里,一个简单的能在外网访问的node项目就完成了,希望会对大家有用]]></content>
      <categories>
        <category>node项目</category>
      </categories>
      <tags>
        <tag>vps</tag>
        <tag>服务器</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于webpack的pc电商首页项目总结]]></title>
    <url>%2F2019%2F08%2F18%2F%E5%9F%BA%E4%BA%8Ewebpack%E7%9A%84pc%E7%94%B5%E5%95%86%E9%A6%96%E9%A1%B5%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[项目演示 已经开源在 我的github 坑写这个栏目的目的主要是方便以后自己回头回顾和深入学习一下每一块东西… webpack相关一.引入iconfont文件123456789@font-face &#123; /*原来的iconfont.css文件*/ font-family: "iconfont"; src: url("font/iconfont.eot?t=1565168052702"); /* IE9 */ src: url("font/iconfont.eot?t=1565168052702#iefix") format('embedded-opentype'), /* IE6-IE8 */ url("font/iconfont.woff?t=1565168052702") format('woff'), url("font/iconfont.ttf?t=1565168052702") format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url("font/iconfont.svg?t=1565168052702#iconfont") format('svg'); /* iOS 4.1- */&#125; 123456789101112@font-face &#123; /*引入在webpack项目中的iconfont需要改动的部分: 1.有个woff2的部分由于webpack出现了错误我干脆就直接移除了 2.url中的引号需要去掉,并且将路径改成项目中的相对路径 */ font-family: "iconfont"; src: url(../font/iconfont.eot?t=1566020851286); /* IE9 */ src: url(../font/iconfont.eot?t=1566020851286#iefix) format('embedded-opentype'), /* IE6-IE8 */ url(../font/iconfont.woff?t=1566020851286) format('woff'), url(../font/iconfont.ttf?t=1566020851286) format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url(../font/iconfont.svg?t=1566020851286#iconfont) format('svg'); /* iOS 4.1- */&#125; 二.创建static文件夹​ 在项目过程中由于要用到读取本地的json文件,但是由于webpack打包之后路径会更改的原因会导致路径的书写变得异常困难,于是便想到和vue-cli一样创建一个不会被处理的static文件夹，并且在配置中设置一下别名，方便自己的引用。 内容来源 1.安装插件cnpm install --save-dev copy-webpack-plugin 建议原来一直使用cnpm就用cnpm,用npm就用npm,否则好像会造成错误 2.在项目下新建一个文件夹用于存储不想被编译的文件夹3.修改webpack配置文件123456789101112131415//webpack.config.js// 在头部引入插件const CopyWebpackPlugin = require('copy-webpack-plugin');// 在plugins配置数组中添加一项plugins: [ new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, './static'),//__dirname 相对于配置文件存在目录的母文件夹,例如我是pathname/webpack.config.js的话,__dirname:pathname to: 'static',//打包后的文件夹输出名称 ignore: ['.*']// 忽略打包文件的后缀名,此处都忽略 &#125; ])] 5. 注意事项static目录下的文件不可通过require或者import的方式引入文件，否则该文件就会参与打包。可以通过http请求静态资源的方式 三.设置别名设置别名更方便我们对地址的引用(不用去思考对引用文件的相对位置了) 内容来源 1234567891011121314151617//webpack.config.jsconst path = require('path');const resolve = dir =&gt; path.resolve(__dirname, dir);module.exports = &#123; entry: './src/main.js', output: &#123; filename: 'bundle.js', path: resolve('dist') &#125;, resolve: &#123; // 设置别名 alias: &#123; '@': resolve('src')// 这样配置后 @ 可以指向 src 目录 注意文件与上文__dirname的相对路径关系 &#125; &#125;&#125;; 1234program (相当于__dirname) ├── asrc│ └── -static // &apos;static&apos;: resolve(&apos;src/static&apos;)├── webpack.config.js 设置完成之后就能在js文件中直接使用绝对的地址了 import &quot;static/your filename&quot; 一些技巧1.隐藏文字,seo优化由于搜索引擎会根据你的标签抓取内容,所以用到一些语义化的标签会更方便搜索引擎的抓取,但是可能我们需要用语义化例如&lt;h1&gt;的标签,但是不希望它在页面中出现,取而代之是一个logo图片,我们就可以把这个文字隐藏起来 1&lt;h1&gt;&lt;a href="./index.html" class="logo fl text-hidden"&gt;淘淘网&lt;/a&gt;&lt;/h1&gt; 12345/* 文字隐藏*/.text-hidden&#123; text-indent: -9999px; overflow: hidden;&#125; 2. 行内元素出现小间距的问题间隔的行内元素之间经常会出现之间会有间距的情况。 ​ 原因：由于html文件中标签之中经常会有空格或者回车的情况下，浏览器会将其也解析成需要空间的字符。 ​ 解决方法： 123//不留间隙&lt;a&gt;摸摸大&lt;/a&gt;&lt;a&gt;你好&lt;/a&gt; 使用浮动 包裹的父元素中的font-size设置为负值,里面的元素设置为0 3. 页面启动的优化手段 按需加载(当其需要显示的时候再加载其中的数据) 缓存数据到本地(注意数据有效时间) cdn ssr(没用到,提前放个坑位以后学习) ​ ​]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>项目总结</tag>
        <tag>webpack</tag>
        <tag>pc页面</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack4基本入门]]></title>
    <url>%2F2019%2F07%2F16%2Fwebpack4%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[本文只是我在学习过程中做的笔记而不是精心整理的博客文章…文笔比较差,供大家参考 官网指南:建议跟学教程:常用 在网页中引用的常见静态资源 js css Images fonts 模板文件 .ejs .jade .vue(在webpack中定义组件的方式,推荐这么用,把组件抽离出来)引入的静态资源多了之后的问题 网页加载速度慢,要发起很多的二次请求 要处理错综复杂的依赖关系 如何解决 合并压缩,精灵图,图片的Base64编码(小图片) 可以使用requireJS,也可以使用webpack 什么是webpack?webpack是前端的一个项目构建工具,基于node.js 如何完美实现上述的2种解决方案 使用Gulp,是基于task任务的,小巧灵活,适合小项目 使用webpack,是基于整个项目进行构建的 关于npm常用命令 npm init 生成package.json文件 npm install packgename -g -g 全局安装 -D 开发环境安装,同时注册到开发环境依赖(devDependencies) –save-dev -P 开发环境安装,同时会注册到生产环境依赖(“dependencies”)中去 –save-prod 妈的我晕 -P最好使用 npm install xxxx –save 代替 cnpm npm 最好项目中就选择一个一直用，否则很容易损坏node_modules,晕 关于开发环境依赖和生产环境依赖 webpack初步阶段 安装 npm init -y 生成package.json文件,-y是一路yes的意思 npm i -g webpack 全局安装 npm i -D webpack 在开发环境中安装(推荐这个嗷!) webpack4.0版本以后需要去再安装一个webpack-cli npm i -D webpack-cli 项目目录 123456|-package.json |- /dist 打包后输出 |- ...这里之后都是自动打包之后的文件 |-/src |- index.js 入口文件 |- index.html 安装lodash (使用示例,是一个js的工具库) npm i lodash -P 编写:src/index文件 123456789101112// es6导入包的方法 ,_类似于jq中的$// 其实_这可以随便取值,下面用这个你命名的值当作_用就行了,因为是默认输出import _ from 'lodash';function createDomElement() &#123; var dom = document.createElement('div'); dom.innerHTML = _.join(['aicoder', '.com', ' wow'], ''); return dom;&#125;document.body.appendChild(createDomElement()); 在工程文件下创建webpack.config.js 123456|-package.json |- /dist 打包后输出 |- index.html |-/src |- index.js 入口文件|-webpack.config.js 配置文件,你的文件通过webpack构建的配置都在这里 123456789101112131415161718//webpack.config.js//是node的相关内容,请求了path模块const path = require('path')module.exports = &#123; // 入口文件 entry:'./src/index.js', // 这mode我现在也不知 mode:'development', // 构建后的出口文件配置 output:&#123; filename:'main.js', // 解析为绝对路径, path.resolve('/foo/bar', './baz');:// 返回: '/foo/bar/baz' path:path.resolve(__dirname,'dist') // __dirname,当前文件所在文件夹路径 &#125;&#125; 坑:如果要操作dom此时记得要加html加载完(window.onload)的前置条件 ↑ 是我刚开始学的时候犯的初级错误,大家可以忽略一下 命令行输入 npx webpack 或者 webpack 就会开始构建 在index.html引用刚刚的构建输出文件 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./main.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body&gt; &lt;p id="yun"&gt;哥真晕了&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; webpack-dev-server的基本使用webpack-dev-server:自动监听文件的改变,自动打包,自动刷新浏览器 npm i -D webpack-dev-server 工具安装到本地开发依赖 安装完毕后,由于我们是在项目中安装的,所以我们无法将其当作命令直接在powershell中运行, 在package.json 中的script 中加入 123456789"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", //插入 "dev":"webpack-dev-server" //"dev":"webpack-dev-server --open" 可以自动打开浏览器 //"dev":"webpack-dev-server --open --port 3000" 自动打开浏览器,端口为3000 默认为8080 //"dev":"webpack-dev-server --open --port 3000 --contentBase src" 自动打开浏览器,端口为3000 默认为8080,进去的时候自动是src文件夹,里面有index.html的话就直接显示了 //"dev":"webpack-dev-server --open --port 3000 --hot" hot 修改处打补丁,而不是每次重新打包编译,并且异步刷新,不用网页刷新,内容直接更新 &#125;, 执行 `npm run dev` 就可以了 webpack-dev-server 帮我们打包生成的bundel.js文件,并没有存放在实际的物理磁盘上,而是直接托管到了电脑的内存中,所以,我们在项目根目录中,根本找不到这个打包好的文件.我们想要动态更新, 12&lt;script src="/bundle.js"&gt;&lt;/script&gt;&lt;!-- 还要把引入的文件改成项目根目录 --!&gt; 我们可以认为,webpack-dev-server 把打包好的文件用一种虚拟的形式托管到了项目的根目录中,虽然我们都看不到它,但是可以认为,和dist src node_modules 平级有一个看不见的文件:bundle.js (放在内存中是为了刷新速度快) 配置命令的另一种方法不是在package.json中配置而是在webpack.config.js中配置 123456789101112131415161718192021const webpack = require('Webpack')// 第二步!!!!!!module.exports = &#123; entry:path.join(__dirname,'./src/main.js'), mode:'development', output:&#123; filename:'bundle.js', path:path.resolve(__dirname,'dist') &#125;, //---------------------------------------- devServer:&#123; //这是配置命令参数的第二种形式,相对来说麻烦一些 open:true,//自动打开浏览器 port:3000, contentBase:'src',//指定托管的根目录 hot:true//启用热更新 的第一步!!!!!!! &#125;, plugins:[//配置插件的结点 new webpack.HotModuleReplacementPlugin()//new一个热更新的模块对象,第三步!!!!!!!!!!!!!!! ] //---------------------------------------------------&#125; html-webpack-plugin的两个基本作用 是个插件:生成内存中的html页面,在上述中html一直是在硬盘中的,和server一起用，大家都说好~ 在使用这个插件之后,我们可以不用自己去处理添加bundle.js,这个插件会帮我们自动插入 打包好的文件 ,并插入到html文件的末尾 npm i -D html-webpack-plugin 123456789101112131415161718192021//只要是插件,就一定要放到plugins里面const htmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; entry:path.join(__dirname,'./src/main.js'), mode:'development', output:&#123; filename:'bundle.js', path:path.resolve(__dirname,'dist') &#125;, //-------------------------------------- plugins:[//配置插件的结点 new htmlWebpackPlugin(&#123; //配置文件//指定 模拟页面,会根据指定的磁盘路径,生成内存中的页面 template:path.join(__dirname,'./src/index.html'), //指定生成的页面的名称 filename:'index.html' &#125;) ] //------------------------------------------&#125; webpack 处理css 模块webpack默认可以解析js ,要处理其他类型的文件,需要安装相应的loader 安装css模块解析的依赖npm install –save-dev style-loader css-loader 在入口文件中import css文件 12// index.jsimport './style/index.css'; //让生成的main.js去帮我们加载这一个模块,同样我们要保证有对应的解析模块 1234567891011121314151617181920212223module.exports = &#123; entry:'./src/index.js', mode:'development', output:&#123; filename:'main.js', // 解析为绝对路径, path.resolve('/foo/bar', './baz');:// 返回: '/foo/bar/baz' path:path.resolve(__dirname,'dist') // __dirname,当前文件所在文件夹路径 &#125;, // --------------------------- module: &#123; // 用于配置所有第三方加载器的规则 rules: [ &#123; // 正则表达式去寻找.css为后缀的,匹配到就用下列加载器处理 test: /\.css$/, // 采用的解析模块,顺序是!!从后到前!! use: ['style-loader', 'css-loader'] &#125; ] &#125; // ------------------------&#125; 在webpack.config.js中添加解析模块规则 加载sass使用sourcemap追踪样式定义源 sass-loader node-sass 123456789101112131415161718192021222324module&#123; rules[&#123; // 这里的test可以是/\.(sc|sa|c)ss$/ 普通css文件也可以经过sass处理 test:/\.scss$/, // 顺序不可以乱,从后往前的 use:[&#123; // 这个只起到注入作业 loader:"style.loader" &#125;,&#123; loader:"css.loader" options:&#123; // 可以让你在网页f12调试样式追踪到源文件中定义的位置 sourceMap:true &#125; &#125;, &#123; loader:"sass.loader" options:&#123; sourceMap:true &#125; &#125; ] &#125;]&#125; import npx webpack 使用PostCSS处理loader(附带:添加css前缀)postcss 反正就是优化你的cssauoprefixer 添加优化前缀,是postcss中的一个功能,postcss中还有很多这种 npm i -D postcss-loader npm i -D autopreficer 12345678910111213141516171819202122232425262728293031323334// webpack.config.js module: &#123; rules: [ &#123; test: /\.(sa|sc|c)ss$/, use: [ 'style-loader', &#123; loader: 'css-loader', options: &#123; sourceMap: true &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; // 微标识符,用啥都行 ident: 'postcss', sourceMap: true, plugins: loader =&gt; [ require('autoprefixer')(&#123; browsers: ['&gt; 0.15% in CN'] &#125;) // 添加前缀 ] &#125; &#125;, &#123; loader: 'sass-loader', options: &#123; sourceMap: true &#125; &#125; ] &#125; ] &#125; url-loader处理图片和字体默认情况下 webpack无法处理url npm i -D url-loader file-loader 1234567891011121314151617181920module：&#123; rules[ &#123; test:/\.(jpg|png|gif|bmp|jpeg)$/, // file-loader是url-loader的内部以来,与项目没关系,所以不用添加 // ?是传参的方式,所有的loader都可以这样传参 use:'url-loader?limit=7632&amp;name=[hash]-[name].[ext]' // url-loader默认将图片设置为base64,设置limit后,大于等于的就不会被转换 // 如果是不被改造成base64的话,会将其上一个hash值构造的路径,这是为了防止文件重名,webpack打包处理之后会把资源放在同一级下,[name] 原来的名字,[ext],原来的后缀名,[hash:8],生成8位的hash值,hash最高32位 // -------另一种方式:更推荐 use: [ &#123; loader: 'url-loader', // 根据图片大小，把图片优化成base64 options: &#123; limit: 10000 &#125; &#125;, &#125; ]&#125; 关于import1234import $ from 'jquery'import './css/index.css'// 写了 ./ 的是会在文件同级目录下寻找, 不写的话默认去node_modules下寻找import 'bootstrap/dist/css/bootstrap.css' webpack中babel的设置babel:将高级语法转化为浏览器能识别的低级语法,webpack只能处理一部分es6语法 安装两套包 npm i -D babel-core babel-loader babel-plugin-transform-runtime负责转换 npm i -D babel-preset-env babel-preset-stage-0 负责语法 设置webpack.config.js 1234567module:&#123; rules:[ &#123;test:/\.js$/,use:'babel-loader',exclude:/node_modules/ // 主要以exclude,要排除node_modules ,因为不排除的话,babel会把所有第三方js文件都打包编译,会非常消耗性能,同时还有可能会导致包的损坏 &#125; ]&#125; 在项目的分目录中,新建一个叫做.babelrc的配置文件,里面的内容属于json格式 1234&#123; "presets":["env","stage-0"], "plugins":["transform-runtime"]&#125; 总结目前就能够了解webpack的基本架构啦,也不可能一一都写下来,想要更多得了解对其他插件或者文件的处理的话建议去刚开始给出的老马教程里面去学一下,文章可能后续有补充,但是最近因为学习生活很慢近期应该就不会啦~]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
        <tag>webpack4</tag>
      </tags>
  </entry>
</search>
